import { CodeMaker } from 'codemaker';
import { JSONSchema4, JSONSchema6 } from 'json-schema';
import { TypeGenerator } from './type-generator';
import { ImportBase } from './base';
// import { httpsGet } from './util';
import { readFileSync } from 'fs-extra'
import * as path from 'path'
import * as $RefParser from "@apidevtools/json-schema-ref-parser";

const DEFAULT_API_VERSION = '1.15.0';

export interface ImportKubernetesApiOptions {
  /**
   * The API version to generate.
   */
  readonly apiVersion: string;

  /**
   * FQNs of API object types to select instead of selecting the latest stable
   * version.
   * 
   * @default - selects the latest stable version from each API object
   */
  readonly include?: string[];

  /**
   * Do not import these types. Instead, represent them as "any".
   * 
   * @default - include all types that derive from the root types.
   */
  readonly exclude?: string[];
}

export class ImportKubernetesApi extends ImportBase {

  public static async match(source: string, argv: any): Promise<ImportKubernetesApiOptions | undefined> {
    if (source !== 'k8s' && !source.startsWith('k8s@')) {
      return undefined;
    }

    return {
      apiVersion: source.split('@')[1] ?? DEFAULT_API_VERSION,
      exclude: argv.exclude,
      include: argv.include
    };
  }

  constructor(private readonly options: ImportKubernetesApiOptions) {
    super()
  }

  public get moduleNames() {
    return ['k8s'];
  }

  protected async generateTypeScript(code: CodeMaker) {
    const schema = await downloadSchema(this.options.apiVersion);
    $RefParser.resolve(schema, (err: any, foo: JSONSchema4 | JSONSchema6 | undefined) => {
      if (err) {
        console.error(err);
      }
      else {
        console.log(JSON.stringify(foo, null, 2));
      }
    })

    const map = findApiObjectDefinitions(schema);
  
    const topLevelObjects = selectApiObjects(map, { include: this.options.include });
  
    code.line(`// generated by armkit`);
    code.line(`import { ApiObject } from 'armkit';`);
    code.line(`import { Construct } from 'constructs';`);
    code.line();
  
    const typeGenerator = new TypeGenerator(schema, { exclude: this.options.exclude });
  
    for (const o of topLevelObjects) {
      this.emitConstructForApiObject(typeGenerator, o);
    }
  
    typeGenerator.generate(code);
  }

  private emitConstructForApiObject(typeGenerator: TypeGenerator, apidef: ApiObjectDefinition) {    
    typeGenerator.emitConstruct({
      fqn: apidef.fullname,
      kind: apidef.basename,
      schema: apidef.schema
    });
  }
}

export interface SelectApiObjectsOptions {
  include?: string[];
}

export function selectApiObjects(map: ApiObjectDefinitions, options: SelectApiObjectsOptions = { }): ApiObjectDefinition[] {
  const result = new Array<ApiObjectDefinition>();
  const include = options.include ?? [];
  for (const defs of Object.values(map)) {
    let selected = defs[defs.length - 1];

    const included = defs.find(x => include.includes(x.fullname));
    if (included) {
      selected = included;
    }

    // select latest stable version
    result.push(selected);
  }

  return result;
}

/**
 * Returns a map of all API objects in the spec (objects that have the
 * 'x-kubernetes-group-version-kind' annotation).
 *
 * The key is the base name of the type (i.e. `Deployment`). Since API objects
 * may have multiple versions, each value in the map is an array of type definitions
 * along with version information.
 * 
 * @see https://kubernetes.io/docs/concepts/overview/kubernetes-api/#api-versioning
 */
export function findApiObjectDefinitions(schema: JSONSchema4): ApiObjectDefinitions {
  const map: ApiObjectDefinitions = { };

  for (const [ typename, def ] of Object.entries(schema.definitions || { })) {    
    console.log({typename, def})
    const type: ApiObjectName = {
      basename: typename,
      fullname: typename,
      namespace: 'foo'
    };

    const list = map[type.basename] ?? [];
    map[type.basename] = list;
    list.push({
      ...type,
      schema: def
    });
  }

  return map;
}

type ApiObjectDefinitions = { [basename: string]: ApiObjectDefinition[] };


interface ApiObjectName {
  basename: string;
  namespace: string;
  fullname: string;
}

interface ApiObjectDefinition extends ApiObjectName {
  schema: JSONSchema4;
}

async function downloadSchema(_inputFile: string) {
  const output = readFileSync(path.join(process.cwd(), 'schema.json'))
  return JSON.parse(output.toString()) as JSONSchema4;
}
